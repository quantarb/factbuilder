from django.db import models
from facts.models import FactDefinition, FactDefinitionVersion
from facts.taxonomy import create_dynamic_producer, safe_execute
from facts.schema_validation import validate_schema_definition
from simple_history.models import HistoricalRecords
import re

class TaxonomyProposal(models.Model):
    """
    Stores proposals generated by the LLM for extending the fact taxonomy.
    """
    question = models.TextField()
    feasibility_analysis = models.TextField()
    proposed_fact_id = models.CharField(max_length=255, blank=True, null=True)
    proposed_logic = models.TextField(help_text="Pseudo-code or description of how to compute this fact")
    
    # NEW: Store proposed schema and template
    proposed_schema = models.JSONField(default=dict, blank=True)
    proposed_template = models.TextField(blank=True, null=True)
    
    # NEW: Structured fields for validation
    proposed_data_type = models.CharField(
        max_length=50, 
        choices=FactDefinition.FactValueType.choices,
        default=FactDefinition.FactValueType.SCALAR
    )
    proposed_requires = models.JSONField(default=list)
    
    LOGIC_TYPE_CHOICES = [
        ('python', 'Python'),
        ('expression', 'Expression (SimpleEval)'),
    ]
    proposed_logic_type = models.CharField(max_length=20, choices=LOGIC_TYPE_CHOICES, default='python')
    
    test_cases = models.JSONField(default=list, blank=True, help_text="List of {context, expected_type, expected_contains}")
    approval_error = models.TextField(blank=True, null=True)

    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=50, default='pending', choices=[
        ('pending', 'Pending Review'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected')
    ])
    
    # Link to the created version if approved
    created_version = models.ForeignKey(FactDefinitionVersion, on_delete=models.SET_NULL, null=True, blank=True)
    history = HistoricalRecords()

    def __str__(self):
        return f"Proposal for: {self.question[:50]}..."
    
    def approve(self, user=None):
        """
        Promotes this proposal to a real FactDefinitionVersion.
        """
        if self.status == 'approved':
            return
            
        self.approval_error = ""
        
        # 0. Auto-detect dependencies if missing
        if not self.proposed_requires:
            # Simple heuristic: look for deps['fact_id'] or names in expression
            # This is a fallback if LLM didn't populate it
            potential_deps = set()
            if self.proposed_logic_type == 'python':
                matches = re.findall(r"deps\['([a-zA-Z0-9_]+)'\]", self.proposed_logic)
                potential_deps.update(matches)
            elif self.proposed_logic_type == 'expression':
                # In expression, any variable name could be a dependency
                # We can't easily parse it without a parser, but we can check against known facts
                known_facts = set(FactDefinition.objects.values_list('id', flat=True))
                # Split by non-alphanumeric
                tokens = re.findall(r"[a-zA-Z0-9_]+", self.proposed_logic)
                for token in tokens:
                    if token in known_facts:
                        potential_deps.add(token)
            
            if potential_deps:
                self.proposed_requires = list(potential_deps)
                self.save()

        # 1. Validate Requires
        existing_ids = set(FactDefinition.objects.values_list('id', flat=True))
        for req in self.proposed_requires:
            if req not in existing_ids:
                self.approval_error = f"Requirement '{req}' does not exist."
                self.save()
                return

        # 2. Validate Data Type
        if self.proposed_data_type not in FactDefinition.FactValueType.values:
             self.approval_error = f"Invalid data type: {self.proposed_data_type}"
             self.save()
             return

        # 3. Validate Schema
        if self.proposed_schema:
            try:
                validate_schema_definition(self.proposed_schema)
            except ValueError as e:
                self.approval_error = f"Invalid schema: {str(e)}"
                self.save()
                return

        # 4. Run Tests
        if self.test_cases:
            producer = create_dynamic_producer(self.proposed_logic)
            for i, test in enumerate(self.test_cases):
                ctx = test.get('context', {})
                # Mock dependencies? For now assume tests provide full context or we need a way to mock deps.
                # If requires is not empty, we can't easily run this without mocking deps.
                # For simplicity, we assume test cases include dependency values in context or we skip dep resolution?
                # The dynamic producer expects (deps, context).
                # We'll assume test['deps'] exists if needed.
                deps = test.get('deps', {})
                
                try:
                    result = safe_execute(producer, deps, ctx, logic_type=self.proposed_logic_type, timeout=3)
                    
                    # Validate result
                    expected_type = test.get('expected_type')
                    if expected_type == 'list' and not isinstance(result, list):
                        raise ValueError(f"Test {i}: Expected list, got {type(result)}")
                    if expected_type == 'dict' and not isinstance(result, dict):
                        raise ValueError(f"Test {i}: Expected dict, got {type(result)}")
                        
                    expected_contains = test.get('expected_contains')
                    if expected_contains and str(expected_contains) not in str(result):
                         raise ValueError(f"Test {i}: Result did not contain '{expected_contains}'")
                         
                except Exception as e:
                    self.approval_error = f"Test {i} failed: {str(e)}"
                    self.save()
                    return

        # 5. Create or Get Definition
        defn, created = FactDefinition.objects.get_or_create(
            id=self.proposed_fact_id,
            defaults={
                'description': f"Auto-generated from: {self.question}",
                'data_type': self.proposed_data_type
            }
        )
        
        # Update data type if it was generic before? (Optional, but safer to keep consistent)
        if not created and defn.data_type != self.proposed_data_type:
             # If existing definition has different type, we might have a conflict.
             # For now, we assume the proposal is correct for the new version.
             pass

        # 6. Determine next version number
        last_version = defn.versions.order_by('-version').first()
        next_ver = (last_version.version + 1) if last_version else 1
        
        # 7. Create Version
        version = FactDefinitionVersion.objects.create(
            fact_definition=defn,
            version=next_ver,
            code=self.proposed_logic,
            requires=self.proposed_requires,
            parameters_schema=self.proposed_schema,
            output_template=self.proposed_template,
            logic_type=self.proposed_logic_type,
            test_cases=self.test_cases,
            status='approved',
            created_by=user,
            change_note=f"Approved from proposal {self.id}"
        )
        
        # Deprecate old approved versions?
        # defn.versions.filter(status='approved').exclude(id=version.id).update(status='deprecated')

        self.created_version = version
        self.status = 'approved'
        self.save()

class CapabilitySuggestion(models.Model):
    suggested_question = models.TextField()
    reasoning = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.suggested_question
